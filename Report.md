 <h1 align = "center">CS383 Course Project : A SimPL Interpreter</h1>

###### tags: `programming language` `SimPL`
## Introduction
In this project, we are required to implement an interpreter for the programming language SimPL, which is a simplified dialect of ML.  It can be used for both functional and imperative programming. The most of syntax, evaluation rules and typing rules are given in our specification. Here I just introduce how I implement a SimPL interpreter with following features:
- [x] Basic fearures
- [x] Bonus features 
    - [x] Mutually recursive combinator 
    - [x] Infinite streams 
    - [x] Garbage collection (of ref cells) 
    - [x] Tail recursion 
    - [x] Lazy evaluation 
    - [x] Other features or optimizations  

## Overall Structure
The overall structure of the whole project is ready for us before we modify any files. All we need to do is complete all the details in the project. There are mainly three packages:
### Parser
This package works as a full-featured parser for SimPL. It will parse the source program (*.spl) and construct an abstract syntax tree(AST). 
* Lexer.java and parser.java: parse the source programs, generated by *.grm and *.lex
* simpl.grm and sim.lex: define the syntax and lexical grammer 
* Symbol.java and Symbols.java: implement symbols in this language
* parser.ast: implement evaluation and typing for each expression, which is exactly what we need to do in this part
### Interpreter
This package define several classes extends abstract class **Value**. Of course they represent each kind of values in simPL. Runtime state and environment model are also defined here.
### Typing
In this package, the typing environment, substitution and every type are represented by a class. The unification is implemented here.

## The Most Basic Stuff
Before getting down to implement evaluation and typing, there are some basic things that should be done first.
### Values
It's an abstract class for values in SimPL. All possible kinds of values inherited from this class, like **IntValue, ConsValue**, e.t.c. We need to implement a *String toString()* method and *boolean equals(Object other)* method for each specific value. The former is used to print the value and the latter is used to compare two values. Take **PairValue** as an example:
```java
// In PairValue
public String toString() {
	return "pair@" + this.v1 + "@" + this.v2;
}
    
@Override
public boolean equals(Object other) {
        // if this and other are both PairValue, then we compare v1 and v2 respectively
	if (other instanceof PairValue) {
		return ((PairValue) other).v1.equals(this.v1) && ((PairValue) other).v2.equals(this.v2);
	}
	return false;       // otherwise return false
}
```
We should be **very careful** about the differences between expressions *a=b* and *a.equals(b)*. We are trying to compare whether two values are presenting the same things, not whether they are the same object in java. Another problem may arise in this part is: how shall we implement *equals()* for non-equality type? I think it doesn't matter because programs where non-equality types are compared will not pass the type checking.

### State
A state s <img src="https://latex.codecogs.com/svg.latex?\in"/> **State** is a triple (E,M,p) where E <img src="https://latex.codecogs.com/svg.latex?\in"/> **Env** is the environment, M <img src="https://latex.codecogs.com/svg.latex?\in"/>  **Mem** is the memory, and p $\in \mathbb{N}$ is the memory pointer. We evaluate an expression with a given state. And the state may be changed during the process of evaluation.
#### Environment
In our lecture, an environment model is proposed in order to optimize the performance of substitution model. It's exactly a mapping from variable names to values. Like any relation, we can perform composition on it. Also we can add new bindings, update a existed one or obtain the value bound to a given variable.
```java
public Value get(Symbol y) {
	if (y == this.x)
		return this.v;      // recursively get the value bingding to y
	return this.E.get(y);       // if not found, will return null
}
```
#### Memory and Pointer
Memory is not a pure functional feature. But we need it since there are Ref and DeRef operations in SimPL. A pointer points to the memory location which can be allocated at that time. It's simply implemented as an integer here. So the memory is a *HashMap<Integer, Value>*. If a memory cell is allocated, we can get the corresponding value stored in it.

#### Initial State
Every time we begin to evaluate a programming, we set the state to be the initial state. It consists of an empty memoty and a initial pointer pointing to 0. But the environment can be initialize with any name-value mappings we want to pre-defined. Here I add all the pre-defined functions to the initial state:
```java
private static Env initialEnv(Env E) {
	E = append(E, "hd", new hd());
	E = append(E, "tl", new tl());
	// add other functions ...
	return E;
}
```
Of course we need to implement these functions later.

### Type Environment
#### Types
**Type** is an abstract class in java. Every type and type variables are inherited from this class. There are several abstract methods defined in this class.
* *boolean isEqualityType()*: whether this type (subclass of Type) is an equality type.
* *Type replace(TypeVar a, Type t)*: replace all free occurrences of the type variable a with a type t. Of course t may be another type variable. 
* *boolean contains(TypeVar tv)*: judge whether type variable tv occurs freely in this type.

Take **ArrowType** as an example:
```java
@Override
public boolean isEqualityType() {
	return false;  // no an equality type
}
@Override
public boolean contains(TypeVar tv) {
	// check t1 and t2 respectively
	return this.t1.contains(tv) || this.t2.contains(tv);
}

@Override
public Type replace(TypeVar a, Type t) {
	// replace t1 and t2 respectively
	return new ArrowType(this.t1.replace(a, t), this.t2.replace(a, t));
}
```

#### Type Environment
Type environment <img src="https://latex.codecogs.com/svg.latex?\Gamma:\mathtt{Var}\rightarrow\mathtt{Typ}"/>  is a mapping from names to arbitrary types. In my project, a TypeEnv is something like a list of mappings from Symbols to Types. It's updateable.The operation $\Gamma[x:t](y)$ is implemented as the following *Type get(Symbol x1)* method:

```java
public Type get(Symbol x1) {
	if (x == x1)
		return t;
	return E.get(x1);
}
```
#### Default Type Environment
Remember that we have add some function values to the initial environment. Hence we should add the corresponding types(or type schemes) to the **DefaultTypeEnv**:
```java
public DefaultTypeEnv() {
	// Add the corresponding type scheme of predefined function values
	this.E = TypeEnv.of(this.E, Symbol.symbol("iszero"), new ArrowType(Type.INT, Type.BOOL));
        // types of some other functions ...
}
```
### Type Result
In fact, it seems we never refer to a type result. Because in our lectures, we always get the type constraints first and then solve them by unification. But here in our project, we **solve a contraint as soon as we get it**. So ater type checking of an expression, we need a structure TypeResult to store the substitution and the type scheme of this term. 

## Typing
We don't annotate the types of terms in a SimPL programming. When we try to interpret a source file, we should first finish the type inference of the program. If there are any errors occurred during the typing, we throw a **TypeError**.
### Unification
This is one of the most important step in the type inference. The unification rules are given in the specification, but there are something different: in method *Substitution unify(Type t)*, we just define how a type scheme is unified with another type scheme but don't compose the substitution with the solution we have already got. The task of composition is done in the method *TypeResult typecheck(TypeEnv E)*. Take *ArrowType* as an example again:
```java
// In ArrowType
@Override
public Substitution unify(Type t) throws TypeError {
	if (t instanceof TypeVar) {    // if t is a type variable
		return t.unify(this);   // exactly {s=a} is the same as {a=s}
	}
	if (t instanceof ArrowType) {    // if t is an arrowtype
               // {s11− > s12 = s21− > s22} => {s11 = s21,s12 = s22}
		return ((ArrowType) t).t1.unify(this.t1).compose(((ArrowType) t).t2.unify(this.t2)); 
	}
	throw new TypeMismatchError();   // type error
}
```
The unification of a type variable is a little different:
```java
// In TypeVar
@Override
public Substitution unify(Type t) throws TypeCircularityError {
	// if t is a type variable and this = t, {a=a} => I
	if (t instanceof TypeVar) {
		if (((TypeVar) t).name == this.name)
			return Substitution.IDENTITY;
	}
	// if t is another type schem, check whether this is in FV(t)
	// if true throw a type error, if false return substitution [this->t]
	if (t.contains(this))
		throw new TypeCircularityError();
	this.equalityType = t.isEqualityType();
	return Substitution.of(this, t);
}
```
Here I list the rules not given in the specification:
<center>
$$
\dfrac{}{(S, \{s1\ \mathtt{list}= s2\ \mathtt{list}\}\cup q)\rightarrow (S,\{s1= s2\}\cup q)}
$$

$$
\dfrac{}{(S, \{s11\times s12= s21\times s22\}\cup q)\rightarrow (S,\{s11= s21, s12=s22\}\cup q)}
$$

$$
\dfrac{}{(S, \{s1\ \mathtt{ref}= s2\ \mathtt{ref}\}\cup q)\rightarrow (S,\{s1= s2\}\cup q)}
$$ {</center>}

### Type Checking
As referred before, a program will be parsed into an abstract syntax tree. The type check is exactly to check every nodes in the tree. This is of heavy workload since there are many kinds of expressions. All the typing rules are given in the specification but only parts of them are in the form of constraint typing rules. We need to transform all of them into constraint typing rules then implement type checking according to them. The implementation of *typecheck()* in **ArithExpr** is typical in expressions which have two sub-expressions.
```java
// In ArithExpr
@Override
public TypeResult typecheck(TypeEnv E) throws TypeError {
	// check the left expression in TypeEnv E, and result tl
	TypeResult tl = this.l.typecheck(E);
	// check the right expression in TypeEnv E composed by the substitution in tl
	TypeResult tr = this.r.typecheck(tl.s.compose(E));
	// compose two substitutions
	Substitution solution = tr.s.compose(tl.s);
	// substitute two type schemes of the sub-expressions
	Type stl = solution.apply(tl.t);
	Type str = solution.apply(tr.t);
	// compose the unification result with the solution before
	Substitution s = str.unify(Type.INT).compose(stl.unify(Type.INT)).compose(solution);
	return TypeResult.of(s, Type.INT);
}
```
The only thing we need to pay attention is that we need to compose tl.s with $E$ to get $E'$ and then check right expression in the context E'. This is corresponding to the substution $q[s/a]$ in  the unification rule. If we forget this, something wrong may happen. For example, we currently have a type variable $a$ in our context $E$. After type checking of the left expression, we get $a=\mathtt{int}$. If we don't replace $a$ with $\mathtt {int}$ and directly check the right expression, we may get another substitution $a=b$. The composition $S:=[a=b]\circ[a=\mathtt{int}]$ does imply $b=\mathtt{int}$. However $S.\mathtt{replace}(b)$ does not necessarily return $a$. But if we replace $a$ with $\mathtt{int}$ in context $E$, we will direcly get $b=\mathtt{int}$, so $S:=[b=\mathtt{int}]\circ[a=\mathtt{int}]$ is exactly what we want to obtain.

The *typecheck* of **Name** will apply the mapping in the type environment:
```java
// In Name
@Override
public TypeResult typecheck(TypeEnv E) throws TypeError {
	Type t = E.get(x);
	if (t == null)
		throw new TypeError("Can't type " + x);
	return TypeResult.of(t);
}
```
The *typecheck* of **Fn** will add new mapping into type environment. And **Rec** is similar to it.
```java
// In Fn
@Override
public TypeResult typecheck(TypeEnv E) throws TypeError {
	// \x:a.e:b : a->b, Add x->a to E and then type e
	TypeVar a = new TypeVar(true);
	TypeVar b = new TypeVar(true);
	TypeResult t = this.e.typecheck(TypeEnv.of(E, this.x, a));
	Type st = t.s.apply(t.t);
	Substitution s = st.unify(b).compose(t.s);
	return TypeResult.of(s, new ArrowType(s.apply(a), s.apply(b)));
}
```
## Semantics
### Pure Functional Features
In every node of ast tree, we need to implement the *Value eval(State s)* method. It's a simple task because all we need to do is translate the evaluation rules into java code. Take **Div** for example, bacause runtime errors may occur during evaluating a division:
```java
// In Div
@Override
public Value eval(State s) throws RuntimeError {
	IntValue lv = (IntValue) this.l.eval(s);    // evaluate left expression
	IntValue rv = (IntValue) this.r.eval(s);    // evaluate right expression
	if (rv.n == 0)
		throw new RuntimeError("Div by zero");    // cannot divide by 0
	return new IntValue(lv.n / rv.n);                 // return lv/rv
}
```
Here we don't need to worried about whether lv and rv are **IntValue**s because we perform type checking first. If they are not of type int, a type error will be raised and stop the interpreter from evaluating that expression. 

The evaluation of **Name** is a little trick because there are two cases: the result we get is a **RecValue** or not.
```java
// In Name
@Override
public Value eval(State s) throws RuntimeError {
	Value v = s.E.get(x);
	// if cannot find the value of x, raise a runtime error
	if (v==null)
		throw new RuntimeError("Variable not found");
	// if E(x)= rec E1 x1 e1, evaluate rec x1=>e1 in the environment E1
	if (v instanceof RecValue) {
		Rec newExpr = new Rec(((RecValue) v).x, ((RecValue) v).e);
		return newExpr.eval(State.of(((RecValue) v).E, s.M, s.p));
	}
	return v;
}
```
Here we raise another runtime error. But it will never happen unless we add some terms with specific types to the **DefaultTypeEnv** but doesn't add corresponding values to the initial environment.
### Imperative Features
It's also very easy to evaluate **Loop**. The semantics of **Ref**, **DeRef** and **Assign** are more interesting because they change the memory and pointer. I evaluate e first in *ref e* and then allocate a memory cell for it. Take **Ref** as an example. The order of allocating a memory cell differs from that in the specification a little, but it doesn't matter.
```java
// In Ref
@Override
public Value eval(State s) throws RuntimeError {
	Value v = this.e.eval(s); // first evaluate e
	int p = s.allocate();     // allocate a new memory cell for value v
	s.putValue(p, v);         // write v to p
	return new RefValue(p);   // return the address of v
}
```

## Further Improvement
### Let Polymorphism
Generally, there are two methods to implement let-polymorphism. I have implemented both in my project.
#### Substitution Method
This is what we have learned in our lecture: 
$$
\dfrac{\Gamma\vdash e_2[e_1/x]:t_2,\;\; q_1\quad \Gamma\vdash e_1:t_1}{\Gamma\vdash \mathtt{let}\;\;x=e_1\;\; \mathtt{in}\;\; e_2:t_2\;\; \mathtt{end},\;\; q_1}
$$
This method has been criticized for its low efficiency. However it's easier to implement. First we add an abstract methos *Expr Substitude(Symbol s, Expr e)* in class **Expr**. Then we implement this method in every ast node, just like what we have done for typing and evaluation. After that we can modify the *typecheck()* methos in **Let**:
```java
// In Let
@Override
public TypeResult typecheck(TypeEnv E) throws TypeError {
	TypeResult t2 = this.e2.Substitude(this.x, e1).typecheck(E);// check e2[e1/x]
	this.e1.typecheck(E);    // check e1
	return t2;
}
```
It's neccessary to check $e_1$, although we don't care what the result is. That is because we care about whether $e_1$ is well-typed or not so the side effect about detecting type errors is essential.
#### Implemented by Universal Polymorphism
The detail of algorithm is discussed in our tutorial. So here I don't explain how this algorithm works. I define a new class called **PolyType** extends **Type**. It's constructed in the form of $\forall t_1,\cdots,\forall t_n, T$. So **PolyType** maintains a *HashSet\<TypeVar> polyList* and a type scheme *t*. Every time we get a polymorphism type in the type environment, we will instantiate it by replacing $t_1,\cdots,t_n$ with new type variables. 
```java
// In PolyType
public class PolyType extends Type {
	HashSet<TypeVar> polyList;
	Type t;

	// given a TypeEnv E and a type t, we need to construct a universal type
	// \forall t_i, t where t_i is the type variables in t but not in E
	// first get the type variables in E as a hashset typeOfE
	// get the type variables in t as a hashset typeVarOft
	// typeVarOft - typeOfE is exactly the set of t_i mentioned above
	public PolyType(Type t, TypeEnv E) {
		HashSet<TypeVar> typeOfE = E.getAllType();
		HashSet<TypeVar> typeVarOft = t.getAllTypeVar();
		typeVarOft.removeAll(typeOfE);
		this.polyList = typeVarOft;
		this.t = t;
	}

	// construct a substitution mapping t_i in polyList to a new typevariable
	// apply this substitution to type scheme t, return an instance of this poly-type
	public Type instantiate() {
		Substitution s = Substitution.IDENTITY;
		for (TypeVar t : this.polyList) {
			s = Substitution.of(t, new TypeVar(t.isEqualityType())).compose(s);
		}
		return s.apply(this.t);
	}
    
	// other methods...  
}
```
By the way, a polymorphism type won't directly appear in unification (only an instance of it will) so we don't need to think how it can unify with another type. Also it' not an equality type. Then in typecheck of **Let**, we construct polymorphsm types:
```java
// In Let
@Override
public TypeResult typecheck(TypeEnv E) throws TypeError {
	// check e1 and construct a polymorphsm type pt
	TypeResult t1 = this.e1.typecheck(E);
	PolyType pt = new PolyType(t1.t, t1.s.compose(E));
	// bind x->pt and check e2
	TypeResult t2 = this.e2.typecheck(TypeEnv.of(t1.s.compose(E), this.x, pt));
	return TypeResult.of(t2.s.compose(t1.s), t2.t);
}
```
Finally only in **Name**, we can get the type of a variable. So we need to check whether the type is a polymorphism type. If so, return an instance of it.
```java
// In Name
@Override
public TypeResult typecheck(TypeEnv E) throws TypeError {
	Type t = E.get(x);
	if (t == null)         // if get nothing, error occur
		throw new TypeError("Can't type " + x);
	if (t instanceof PolyType)     // if it's a poly-type,instantiate it
		return TypeResult.of(((PolyType) t).instantiate());
	return TypeResult.of(t);       // return directly in other cases
}
```
By now, we have implemented let-polymorphism. We should notice that in the worst case, this algorithm still takes exponential time to get the answer. Because in the nested let expressions, the length of type itself may grow exponentially. When there are two many type variables need to be replaced, *java.lang.StackOverflowError* may occur.
### Predefined Functions
#### Semantics
A function value is a closure of the environment, a variable and an expression. As for *fst*, *snd*, *hd* and *tl*, I defined an expression class for each function. For example, I defined **hd** inherited from **UnaryExpr** for *fst*.
```java
// In hd
public class hd extends FunValue {
	private static Expr HD(Symbol s) {
		final class Hd extends UnaryExpr {
			public Hd(Expr e) {
				super(e);
			}

			@Override
			public TypeResult typecheck(TypeEnv E) throws TypeError {
				// the type of hd is given in the DefaultTypeEnv
				// we never call this function
				return null;
			}

			@Override
			public Value eval(State s) throws RuntimeError {
				// if e is a nil raise a runtime error
				// else return the head of list
				Value p = this.e.eval(s);
				if (p.equals(Value.NIL))
					throw new RuntimeError("Hd nil");
				return ((ConsValue) p).v1;
			}
		}
		return new Hd(new Name(s));
	}

	public hd() {
		// return a closure
		super(Env.empty, Symbol.symbol("x"), HD(Symbol.symbol("x")));
	}
}
```
*iszero*, *succ* and *pred* are much easier. We can define them by derived expressions, i.e. constructed from existing expressions. $\mathtt{iszero}\rightarrow\{\lambda x.x=0, .\}$, $\mathtt{pred}\rightarrow \{\lambda x.x-1,. \}$, $\mathtt{succ}\rightarrow \{\lambda x.x+1,.\}$
```java
// In iszero 
public iszero() {
	// FunValue of {EmptyEnv, x, x=0}
	super(Env.empty, Symbol.symbol("x"), new Eq(new Name(Symbol.symbol("x")), new IntegerLiteral(0)));
}
```
#### Types
As mentioned in the specification, 
> They are predefined names in the topmost environment, work in the same way as user-defined functions, and can be bound to other values.

So $\mathtt{fst}\;\; l$ and $\mathtt{let}\;\; f=\cdots\;\;\mathtt{in}\;\;f\;\;l\;\;\mathtt{end}$. The most important things is that their types behaves like polymorphism types. So when we add their types to the **DefaultTypeEnv**, we should add corresponding **PolyType**s.
```java
// In DefaultTypeEnv
public DefaultTypeEnv() {
	// Add the corresponding polymorphism type scheme of predefined function values
	TypeVar v1 = new TypeVar(true);
	TypeVar v2 = new TypeVar(true);
	this.E = TypeEnv.of(TypeEnv.empty, Symbol.symbol("fst"), new PolyType(new ArrowType(new PairType(v1, v2), v1)));
	// Add other types ...
}
```
### Test
I have implement the whole basic interpreter (without any bonus features) now! So I can test it on all example programs. I have added some cases to the examples. All of the results are shown in the *Appendix*. The source file *pcf.fibonacci.spl* takes exponential time to solve the fibonacci problem, which may result in a *stack overflow* error. We need to turn the size of stack a little larger if this occurs. The results are shown in the [appendix](#Appendix).

## Bonus Features
### Garbage Collection
#### Inplemantation
We have learned several garbage collection algorithms before. We can apply any one to this interpreter as long as we know how to determine whether a memory cell is garbage or not. Let's think about this problem: a memory cell $p$ can be fetched only when there exist some mapping in the form of $x\mapsto(\mathtt{ref}, p)$ in the current environment. This kind of values can only be created by expression $\mathtt{ref}\  e$, when we allocate a memory cell. So every time we call *allocate()*, we can apply the garbage collection algorithm. Here I choose Copy Collection. So there are two **Mem** in one state: *from* and *to*. After we apply collect and copy, we swap these two memory list. The new structure of **State** is shown as follows:
```java
public class State {

	public final Env E;
	private static boolean gc_enabled = false;
	private static boolean debug = false;
	private int from = 0;
	private static int MAX_HEAP = 10;
	public final Mem[] M = new Mem[2];
	public final Int p;

        // constructor and some other functions

	protected void copyCollection() {
		HashSet<RefValue> reachable = this.E.getRefValue();  // collect
		int ad = 0;
		for (RefValue v : reachable) {
			this.M[1 - from].put(ad, this.M[from].get(v.p));  // copy
			ad += 1;
		}
		this.p.set(ad);
		this.from = 1 - this.from;  // swap
	}

	public int allocate() throws RuntimeError {
		int address = this.p.get();
		// if the heap is full, try to collect garbage
		if (address == State.MAX_HEAP) {
			if (State.gc_enabled)
				this.copyCollection();
			address = this.p.get();
			if (address == State.MAX_HEAP)
				throw new RuntimeError("HeapOverflow"); // gc doesn't work, throw heap overflow error
		}
		this.p.set(address + 1);   // allocate a memory cell
		return address;
	}

	// some other functions
}
```
#### Test
Now we have 'installed' the garbage collector, just try to figure out whether it works well! I wrote a program *gctest.spl*
```SimPL=
let a = ref 0 in
	let b= ref 1 in
		a := !a + !b;
		let c = ref 2 in
			a :=!a+!c;
			let d = ref 6 in
				a := !a + !d
			end
		end
	end;
	let e = ref 3 in
		a := !a + !e
	end;
	let f = ref 4 in
		a := !a + !f
	end;
	let g = ref 5 in
		a := !a + !g
	end;
	!a 
end
```
I test this program in several cases: GC disabled, GC enabled with a heap of size 10, GC enabled with a heap of size 5, GC enabled with a heap of size 3. The result implies that our garbage collector works as expected:
```java
GC disabled
doc/examples/gctest.spl
int  // gc disabled, nothing happened
Alloc:@0; Alloc:@1; Alloc:@2; Alloc:@3; Alloc:@4; Alloc:@5; Alloc:@6; 
21

GC enabled heap size 10
doc/examples/gctest.spl
int  // the size of heap is large enough, nothing happened
Alloc:@0; Alloc:@1; Alloc:@2; Alloc:@3; Alloc:@4; Alloc:@5; Alloc:@6; 
21

GC enabled heap size 5
doc/examples/gctest.spl
int  // the heap size is only 5 so copy-collection happened
Alloc:@0; Alloc:@1; Alloc:@2; Alloc:@3; Alloc:@4; 
[DEBUG][From GC]Before GC: 5 cells in total.
[DEBUG][From GC]After GC: 1 cells in total.
Alloc:@1; Alloc:@2; 
21

GC enabled heap size 3
doc/examples/gctest.spl
int  // the heap size is 3 so copy-collection happened here
Alloc:@0; Alloc:@1; Alloc:@2; 
[DEBUG][From GC]Before GC: 3 cells in total.
[DEBUG][From GC]After GC: 3 cells in total.
runtime error  // but none of those are garbage, HeapOverflow occurred
```
### Lazy Evaluation
#### Implementation
Here I adopt the method provided in [Chapter 4.2](https://mitpress.mit.edu/sites/default/files/sicp/full-text/book/book-Z-H-27.html#%_sec_4.2.2) of the famous textbook [Structure and Interpretation of Programs(SICP)](https://mitpress.mit.edu/sites/default/files/sicp/full-text/book/book.html). If we pass arguments to a function application expression (also let expression), we create a so-called **ThunkValue**, which refer to a closure of current environment and the whole expressions. It's something like a function value but they are different because we need to be more considerate about the implementation of a thunk. 
* Firstly, we need to design a *Value forceEval(State S)* method for it so that we can get the actual value of it when we need. 
* Secondly, we also need to pay attention to the efficiency of our interpreter. We try to memorize the value of a thunk after it has been evaluated once. Otherwise the implementation of lazy evaluation will cost a lot in repeatedly computing the same expression, therefore the benefits of lazy evaluation is completely overweighed by the disadvantages 
* Thirdly, we are supposed to only allocate a memory cell when we evaluate a thunk value. This feature is kind of orthogonal with garbage collector. To make sure there are no error caused by the garbage collector and lazy evaluation, we need to prevent them from invoked at the same time.
```java
public class ThunkValue extends Value {

	Expr exp;
	Env e;
	boolean eval;
	Value v;

	public ThunkValue(Env e, Expr exp) {
		this.exp = exp;
		this.e = e;
		this.eval = false;
		this.v = null;
	}

	public Value forceEval(State S) throws RuntimeError {
		// we never compute the same thunk twice
		if (this.eval == true)
			return this.v;
		// if not evaluated before, evaluate it and memorize the value
		// send message to GC, don't apply copy collection when evaluating exp
		Expr.setThunk(true);
		this.v = this.exp.eval(State.of(this.e, S.getMem(), S.p));
		Expr.setThunk(false);
		this.eval = true;
		return this.v;
	}

	public boolean equals(Object other) {
		// never compare two thunk values
		return false;
	}
}
```
In **App** and **Let**, we create a $Var\mapsto\text{Thunk}$ mapping and add it into the environment.
```java
// In App
@Override
public Value eval(State s) throws RuntimeError {
	FunValue fun = (FunValue) this.l.eval(s);
	Value argu = null;
	// if lazy_eval is enabled, create a thunk instead of evaluating it
	if (Expr.isLazy())
		argu = new ThunkValue(s.E.clone(), this.r);
	else
		argu = this.r.eval(s);
	return fun.e.eval(State.of(new Env(fun.E, fun.x, argu), s.getMem(), s.p));
}
```
In **Name** we get the actual value of a thunk (if it's a thunk).
```java
@Override
public Value eval(State s) throws RuntimeError {
	Value v = s.E.get(x);
	// Omit ...
	if (v instanceof ThunkValue) {
		return ((ThunkValue) v).forceEval(s);
	}
	return v;
}
```
#### Test
I have designed two simple but very impressive program, which reveal the essential differences between call-by-value and lazy evaluation. It also distinguishes whether the implementations of thunks only evaluate the expression only once.
```ml=
(*lazyeval1.spl*)
(*call-by-value: 6*)
(*lazy-eval: 2*)
(*if we don't memorize the value in a thunk: 0 because of a=ref 0*)
let a= ref 0 in
	(fn x=>fn y=>fn z=>y;!a) (a:=!a+1) (a:=!a+2) (a:=!a+3)
end 

(*lazyeval2.spl*)
(*call-by-value: runtime error*)
(*lazy-eval: 1*)
(fn x=>fn y=>if true then x else y) (1 / 1) (1 / 0)
```
The results are in line with expectations:
```
Call by value:
doc/examples/lazyeval1.spl
int
6
doc/examples/lazyeval2.spl
int
runtime error
Lazy evaluation:
doc/examples/lazyeval1.spl
int
2
doc/examples/lazyeval2.spl
int
1
```
#### Further Improvement
I have mentioned before that the lazy evaluation is not so orthogonal with the imperative features. And the test programs also revealed that sometimes the side effects of the program may never take place under lazy evaluation. So I highly recommand that we add two built-in functions *delay* and *force* into the initial environment and disabled lazy evaluation so that the programmers can control whether or not arguments are to be delayed. But now we don't force a thunk in **Name**, so we need to type a thunk value. As is refered in most of the books, a thunk can be represented with type $\text{Unit}\rightarrow s$. Since users cannot use unit value directly, this type is safe enough to type and evaluate these two functions.


$$
v::=\cdots|(\mathrm{thunk},\;E,\;e)
$$

$$
\dfrac{\Gamma\vdash e:t,\;q}{\Gamma\vdash \mathrm{delay}\;\;e:\text{Unit}\rightarrow\;t,\;q}\qquad\dfrac{\Gamma\vdash e:t,\;q}{\Gamma\vdash \mathrm{force}\;\;e:a,\;\{t=\text{Unit}\rightarrow\;a\}\cup\;q}
$$


$$
\dfrac{}{E,M,p;(\mathrm{delay}\;\;e)\Downarrow(\mathrm{thunk},\;E,\;e)}
$$

$$
\dfrac{E,M,p;e\Downarrow M',p',(\mathrm{thunk},\; E_1,\;e_1)\qquad\;E_1,M',p';e_1\Downarrow\;M'',p'',v_2}{E,M,p;(\mathrm{force}\;\;e)\Downarrow\;M'',p'',v_2}
$$

Then we need to modify simpl.grm and simpl.lex. Run the makefile and generate lex.java
```java
// In simpl.grm
terminal APP, DELAY, FORCE;
...
precedence left APP, LPAREN, DELAY, FORCE;
...
e ::= NUM:n {: RESULT = new IntegerLiteral(n.intValue()); :}
    | ...
    | DELAY e:e {: RESULT = new Delay(e); :}
    | FORCE e:e {: RESULT = new Force(e); :}
// In simpl.lex
<YYINITIAL> {
    ...
    "delay"	  { return token(DELAY); }
    "force"	  { return token(FORCE); }
```
Finally type and evaluate these two expressions:
```java
public class Delay extends UnaryExpr {
	// ...

	@Override
	public TypeResult typecheck(TypeEnv E) throws TypeError {
		TypeResult t = this.e.typecheck(E);
		Type st = t.s.apply(t.t);
		Type result = new ArrowType(Type.UNIT, st);
		return TypeResult.of(t.s, result);
	}

	@Override
	public Value eval(State s) throws RuntimeError {
		return new ThunkValue(s.E, this.e);
	}
}
public class Force extends UnaryExpr {
	// ...

	@Override
	public TypeResult typecheck(TypeEnv E) throws TypeError {
		TypeResult t = this.e.typecheck(E);
		Type st = t.s.apply(t.t);
		TypeVar a = new TypeVar(true);
		Substitution solution = st.unify(new ArrowType(Type.UNIT, a)).compose(t.s);
		return TypeResult.of(solution, a);
	}

	@Override
	public Value eval(State s) throws RuntimeError {
		Value v = this.e.eval(s);
		if (v instanceof ThunkValue)
			return ((ThunkValue) v).forceEval(s);
		throw new RuntimeError("Not a thunk");
	}
}
```
The test result is the same as the latter version
```java
(fn x=>fn y=>if true then (force x) else (force y)) (delay (1 / 1)) (delay (1 / 0))
```
```
doc/examples/lazyeval3.spl
int
1
```
### Infinite Streams
#### Implementation
The infinite stream is very similar to a lazy list. According to the [Chapter 4.2 of SICP](https://mitpress.mit.edu/sites/default/files/sicp/full-text/book/book-Z-H-27.html#%_sec_4.2.2), we can implement an infinite stream by the *ThunkValue*. Therefore the type of a streams is in the form of $s\rightarrow(\mathrm{Unit}\rightarrow\;s\;\mathrm{stream})\rightarrow{s\;\mathrm{stream}}$. The middle part is exactly a thunk. But the **StreamType** is necessary because type curcularity errors will occur if don't introduce a new type. Here I modify the syntax of simPL:

$$
e::=\cdots|(\mathrm{stream},\;e_1,\;e_2)|\mathrm{car}\;\;e|\mathrm{cdr}\;\;e
$$

$$
v::=\cdots|(\mathrm{stream},\;v_1,\;v_2)
$$

$$
t::=\cdots|t\;\;\mathrm{stream}
$$

$$
\dfrac{\Gamma\vdash e_1:t_1,\;q_1\qquad \Gamma\vdash e_2:t_2,\;q_2}{\Gamma\vdash (\mathrm{stream},\;e_1,\;e_2):t_1\;\;\mathrm{stream},\;q_1\cup\;q_2\cup\{t_2=t_1\;\;\mathrm{stream}\}}
$$

$$
\dfrac{E,M,p;e_1\Downarrow M',p',v_1\qquad\;E,M',p';e_2\Downarrow\;M'',p'',v_2}{E,M,p;(\mathrm{stream},\;e_1,\;e_2)\Downarrow\;M'',p'',(\mathrm{stream},\;v_1,\;v_2)}
$$

$$
\dfrac{E,M,p;e\Downarrow M',p',(\mathrm{stream},\;v_1,\;(\mathrm{thunk},\;E_1,\;e_2)))}{E,M,p;(\mathrm{car},\;e)\Downarrow\;M'',p'',v_1}
$$

$$
\dfrac{E,M,p;e\Downarrow M',p',(\mathrm{stream},\;v_1,\;(\mathrm{thunk},\;E_1,\;e_2)))\qquad\;E_1,M',p';e_2\Downarrow\;M'',p'',v_2}{E,M,p;(\mathrm{cdr},\;e)\Downarrow\;M'',p'',v_2}
$$

We should also add definition of *stream* into simpl.grm and simpl.lex, like what we have done before. The **StreamType** is almost the same with the **ListType**. The details of **Stream** are shown as follows:
```java
public class Stream extends BinaryExpr {

	// ...
    
	@Override
	public TypeResult typecheck(TypeEnv E) throws TypeError {
		TypeResult tl = this.l.typecheck(E);
		TypeResult tr = this.r.typecheck(tl.s.compose(E));
		Substitution solution = tr.s.compose(tl.s);
		Type stl = solution.apply(tl.t);
		Type str = solution.apply(tr.t);
		Substitution s = str.unify(new StreamType(stl)).compose(solution);
		return TypeResult.of(s, new StreamType(stl));
	}

	@Override
	public Value eval(State s) throws RuntimeError {
		Value lv = this.l.eval(s);
		return new StreamValue(lv, new ThunkValue(s.E, this.r));
	}

}
```
The *car* and *cdr* are similar to *hd* and *tl*. But *cdr* forces the thunk to evaluate its expression and memorize the value. Finally the type of *car* is $\forall\;\alpha\;(\alpha\;\mathrm{stream}\rightarrow\alpha)$. The type of *cdr* is $\forall\;\alpha\;(\alpha\;\mathrm{stream}\rightarrow\alpha\;\mathrm{stream})$

#### Test
We can implement some operations of streams and then generate an infinite factorial stream by this operations.
```
let mulstream=rec f=>fn s1=>fn s2=>(stream, ((car s1) * (car s2)), (f (cdr s1) (cdr s2))) in
	let addstream=rec f=>fn s1=>fn s2=>(stream,((car s1)+(car s2)), (f (cdr s1) (cdr s2))) in
		let onestream=rec f=>(stream,1,f) in
			let integerstream=rec f=>(stream,1,(addstream onestream f)) in
				let factorial=rec f=>(stream,1,(mulstream (cdr integerstream) f)) in
					let get=rec f=>fn s=>fn n=>if n=1 then (car s) else f (cdr s) (n-1) in
						get factorial 10
					end
				end
			end
		end
	end
end
```
The above program return the value of $10!$. Notice that every time we try to access the n-th element in a stream, we need to compute the first n-1 elements and memorize them. So sometimes Java Heap/Stack Overflow (not SimPL) may occur.
```
doc/examples/infinitestream.spl
int
3628800
```

### More Imperative Features
#### Implementation
Here I think we need to implement a *display* and *newline* function to print the value in anywhere we want while programming. They are simple but make the language more user-friendly
```java
// In display
@Override
public Value eval(State s) throws RuntimeError {
	Value v = this.e.eval(s);
	if (v instanceof ConsValue)
		System.out.print("(" + ((ConsValue) v).getValue());
	else
		System.out.print(v);
	return Value.UNIT;
}
```
I also add a *define* to get rid of nested let. The syntex is $(\mathrm{define}\;\;x\Rightarrow\;e)$. This enable us to add an value to the global environment and type environment. When we try to evaluate or typecheck **Seq**, we need to check whether the left expression is a **Define**. If true, we check or evaluate next expression using the extended environment.
```java
// In Seq
@Override
public Value eval(State s) throws RuntimeError {
	if (this.l instanceof Define) {
		Value v = ((Define) this.l).eval_define(s);
		return this.r.eval(State.of(new Env(s.E, ((Define) this.l).x, v), s.getMem(), s.p));
	}
	this.l.eval(s);
	return this.r.eval(s);
}
```
#### Test
Now we can rewrite the last program as follows:
```
(define mulstream=>rec f=>fn s1=>fn s2=>(stream, ((car s1) * (car s2)), (f (cdr s1) (cdr s2))));
(define addstream=>rec f=>fn s1=>fn s2=>(stream,((car s1)+(car s2)), (f (cdr s1) (cdr s2))));
(define onestream=>rec f=>(stream,1,f));
(define integerstream=>rec f=>(stream,1,(addstream onestream f)));
(define factorial=>rec f=>(stream,1,(mulstream (cdr integerstream) f)));
(define get=>rec f=>fn s=>fn n=>if n=1 then (car s) else f (cdr s) (n-1));
(get factorial 10)
```
Polymorphism is also available:
```
(define a=>fn x=>x);
(define b=>a 1);
(define c=>a false);
(if c then b else 0)
```
```
doc/examples/define.spl
int
0
doc/examples/infinitestream.spl
int
3628800
```

### Mutually Recursive Combinator
#### Implementation
According to [the Chapter 11 of TAPL](http://kevinluo.net/books/book_Types%20and%20Programming%20Languages%20-%20Benjamin%20C.%20Pierce.pdf), we can define a **RecordValue** and then apply fix point combinator to it. First I modify the grammer and extend the SimPL for Records.

$$
e::=\cdots|\{{l=e_1,\;e_2}\}|(\mathrm{proj},\;\;e,\;\;l)|\mathrm{recordnil}
$$

$$
v::=\cdots|\{l=v_1,\;v_2\}|\mathrm{recordnil}
$$

$$
t::=\cdots|\{l:t_1,\;t_2\}|\{\}
$$

$$
\dfrac{\Gamma\vdash e_1:t_1,\;q_1\qquad \Gamma\vdash e_2:t_2,\;q_2\qquad t_2=\{l_1':t_1',t_2'\}\;\text{or}\;\{\}}{\Gamma\vdash \{{l_1=e_1,\;e_2}\}:\{l_1:t_1,\;t_2\},\;q_1\cup\;q_2}
$$

$$
\dfrac{}{\Gamma\vdash \mathrm{recordnil}:\{\},\{\}}
$$

$$
\dfrac{\Gamma\vdash e:t,\;q\qquad\;\;l_1:t_1\in\;t}{\Gamma\vdash (\mathrm{proj},\;\;e,\;\;l_1):t_1,\;q}
$$

$$
\dfrac{E,M,p;e_1\Downarrow M',p',v_1\qquad\;E,M',p';e_2\Downarrow\;M'',p'',v_2}{E,M,p;\{{l=e_1,\;e_2}\}\Downarrow\;M,p,\{{l=v_1,\;v_2}\}}
$$

$$
\dfrac{}{E,M,p;\mathrm{recordnil}\Downarrow\;M'',p'',\mathrm{recordnil}}
$$

$$
\dfrac{E,M,p;e\Downarrow M',p',v\qquad l_1:v_2\in v}{E,M,p;(\mathrm{proj},\;e,\;l_1)\Downarrow\;M,p',v_1}
$$


Take **Record** as an example:
```java
public class Record extends Expr {

	private Symbol x;
	private Expr l;
	private Expr r;

	public Record(Symbol x, Expr l, Expr r) {
		this.x = x;
		this.l = l;
		this.r = r;
	}

	public String toString() {
		return "{" + this.x + "=" + this.l + ", " + this.r + "}";
	}

	@Override
	public TypeResult typecheck(TypeEnv E) throws TypeError {
		TypeResult tl = this.l.typecheck(E);
		TypeResult tr = this.r.typecheck(tl.s.compose(E));
		Substitution solution = tr.s.compose(tl.s);
		Type stl = solution.apply(tl.t);
		Type str = solution.apply(tr.t);
		if (!(str instanceof RecordType))
			throw new TypeMismatchError();
		return TypeResult.of(solution, new RecordType((RecordType) str, this.x, stl));
	}

	@Override
	public Value eval(State s) throws RuntimeError {
		Value lv = this.l.eval(s);
		Value rv = this.r.eval(s);
		return new RecordValue(this.x, lv, rv);
	}

	//...
}
```
But here I only introduce record to implement mutual recursion. *This kind of value are **not expected** to be used for other purposes. Because the constraint typing rules are no very perfect and we haven't implement subtyping or something else.*

Now we can directly define mutually recursive funtions:
```
(define oddeven=>rec f=>{iseven=fn x=>if iszero x then true else (proj, f, isodd) (pred x),
		{isodd=fn x=>if iszero x then false else (proj, f, iseven) (pred x),
		recordnil}});
(define multirec=>rec f=>{iszero=fn x=>if x=0 then true else if x=1 then false else if x=2 then false else (proj, f, istwo) (x-1),
		{isone=fn x=>(proj, f,iszero) (x-1),
		{istwo=fn x=>(proj, f,isone) (x-1),
		recordnil}}});
(display oddeven);
newline;
(display multirec);
newline;
(display ((proj, multirec, isone) 10));
newline;
(display ((proj, multirec, istwo) 10));
newline;
(display ((proj, multirec, iszero) 10));
newline;
(display ((proj, oddeven, iseven) 10));
newline;
((proj, oddeven, isodd) 10)
```
The result is:
```java
doc/examples/mutualrecursion.spl
bool                       // type
{iseven=fun, isodd=fun}
{iszero=fun, isone=fun, istwo=fun}
true
false
false
true
false
```
### Tail Recursion
#### Some Discussion
I haven't implement tail recursion yet. After reading the correspoinding chapters in the reference textbook, I found that we could do little to optimize the interpreter in this way. Since our interpreter is still very high level, the management of stacks depend on Java. It's hard to simulate the registers, memory and optimaize tail recursions in such a high level. 

But on the other hand, I have tried to optimize parts of tail calling. I have reduced the depth of stack frames while interpreting sequences of commands or while loops.

To be more specific, if we want to optimize the rail recursion
```
(define tail=>rec f=>fn x=>fn y=>if y=0 then x else f (x+y) (y-1));
(tail 0 10000)
```

We can transform this tail recursion into:
```
(define x=>ref 0);
(define y=>ref 10000);
(while !y<>0 do x:=!x+!y; y:=!y-1);
!x
```
But this step of optimization is useless by now because we push a stack while evaluating every expression in **Seq** and **While**. Also, **Group** expressions meaninglessly keep pushing stacks. So even in this simple program, StackOverflow occurs. If we hope to optimize the tail recursions, we should first optimize some typical tail calls.  Hence I modify the evaluation strategy so that we can simulate a loop and a sequence of commands by a actual loop and sequences of commands:
```java
// In Seq
@Override
public Value eval(State s) throws RuntimeError {

	if (Expr.opt) {
		Expr e, l0 = this.l, r0 = this.r;
		State s0 = s;
		while (true) { // Loop instead of recursively calling eval()
			if (l0 instanceof Group && ((Group) l0).is_define())
				e = ((Group) l0).get_define();
			else
				e = l0;

			if (e instanceof Define) {
				Value v = ((Define) e).eval_define(s0);
				s0 = State.of(new Env(s0.E, ((Define) e).x, v), s0.getMem(), s0.p);
			} else {
				l0.eval(s0);
			}
			while (r0 instanceof Group)
				r0 = ((Group) r0).e;
			if (r0 instanceof Seq) {
				l0 = ((Seq) r0).l;
				r0 = ((Seq) r0).r;
			} else
				break;
		}
		while (r0 instanceof Loop)
			return Value.SIGNAL;
		return r0.eval(s0);
	}
         // without optimization
	Expr e;
	if (this.l instanceof Group && ((Group) this.l).is_define())
		e = ((Group) this.l).get_define();
	else
		e = this.l;

	if (e instanceof Define) {
		Value v = ((Define) e).eval_define(s);
		return this.r.eval(State.of(new Env(s.E, ((Define) e).x, v), s.getMem(), s.p));
	}
	this.l.eval(s);
	return this.r.eval(s);
}
```
```java
// In Loop
@Override
public Value eval(State s) throws RuntimeError {
	while (true) {
		BoolValue cond = (BoolValue) this.e1.eval(s);
		if (cond.equals(Value.TRUE)) {
			Seq newExpr = new Seq(this.e2, this);
			Value v = newExpr.eval(s);
			if (v != Value.SIGNAL)
				// without optimization
				// create lots of stack frames here
				return newExpr.eval(s);  
			else
				// exactly one stack for each level of loop
				// exit the stack after executing the sequences
				continue;
		} else
			return Value.UNIT;
	}
}
```
#### Test
I test this feature on the programs mentioned before.
```
doc/examples/tail.spl
int
50005000    // with management of stack
doc/examples/tail.spl
int
StackOverflow!    // without management
```
It seems that the performance of the opitimized version of interpreter is better than the former one,

## Appendix
### Testing Results
```
doc/examples/plus.spl
int
3
doc/examples/factorial.spl
int
24
doc/examples/gcd1.spl
int
1029
doc/examples/gcd2.spl
int
1029
doc/examples/max.spl
int
2
doc/examples/sum.spl
int
6
doc/examples/map.spl
((tv127 -> tv128) -> (tv127 list -> tv128 list))
fun
doc/examples/pcf.sum.spl
(int -> (int -> int))
fun
doc/examples/pcf.even.spl
(int -> bool)
fun
doc/examples/pcf.minus.spl
int
46
doc/examples/pcf.factorial.spl
int
720
doc/examples/pcf.fibonacci.spl
int
StackOverflow!
doc/examples/letpoly.spl
int
0
doc/examples/pcf.twice.spl
int
16
doc/examples/pcf.lists.spl
type error
doc/examples/true.spl
type error
doc/examples/polymorphism.spl
int
5
doc/examples/letpolytest1.spl
bool
true
doc/examples/letpolytest2.spl
bool
true
doc/examples/letpolytest3.spl
int
55
doc/examples/letpolytest4.spl
(((((((((tv473 -> tv473) * (tv473 -> tv473)) * ((tv473 -> tv473) * (tv473 -> tv473))) * (((tv473 -> tv473) * (tv473 -> tv473)) * ((tv473 -> tv473) * (tv473 -> tv473)))) * ((((tv473 -> tv473) * (tv473 -> tv473)) * ((tv473 -> tv473) * (tv473 -> tv473))) * (((tv473 -> tv473) * (tv473 -> tv473)) * ((tv473 -> tv473) * (tv473 -> tv473))))) * (((((tv473 -> tv473) * (tv473 -> tv473)) * ((tv473 -> tv473) * (tv473 -> tv473))) * (((tv473 -> tv473) * (tv473 -> tv473)) * ((tv473 -> tv473) * (tv473 -> tv473)))) * ((((tv473 -> tv473) * (tv473 -> tv473)) * ((tv473 -> tv473) * (tv473 -> tv473))) * (((tv473 -> tv473) * (tv473 -> tv473)) * ((tv473 -> tv473) * (tv473 -> tv473)))))) * ((((((tv473 -> tv473) * (tv473 -> tv473)) * ((tv473 -> tv473) * (tv473 -> tv473))) * (((tv473 -> tv473) * (tv473 -> tv473)) * ((tv473 -> tv473) * (tv473 -> tv473)))) * ((((tv473 -> tv473) * (tv473 -> tv473)) * ((tv473 -> tv473) * (tv473 -> tv473))) * (((tv473 -> tv473) * (tv473 -> tv473)) * ((tv473 -> tv473) * (tv473 -> tv473))))) * (((((tv473 -> tv473) * (tv473 -> tv473)) * ((tv473 -> tv473) * (tv473 -> tv473))) * (((tv473 -> tv473) * (tv473 -> tv473)) * ((tv473 -> tv473) * (tv473 -> tv473)))) * ((((tv473 -> tv473) * (tv473 -> tv473)) * ((tv473 -> tv473) * (tv473 -> tv473))) * (((tv473 -> tv473) * (tv473 -> tv473)) * ((tv473 -> tv473) * (tv473 -> tv473))))))) * (((((((tv473 -> tv473) * (tv473 -> tv473)) * ((tv473 -> tv473) * (tv473 -> tv473))) * (((tv473 -> tv473) * (tv473 -> tv473)) * ((tv473 -> tv473) * (tv473 -> tv473)))) * ((((tv473 -> tv473) * (tv473 -> tv473)) * ((tv473 -> tv473) * (tv473 -> tv473))) * (((tv473 -> tv473) * (tv473 -> tv473)) * ((tv473 -> tv473) * (tv473 -> tv473))))) * (((((tv473 -> tv473) * (tv473 -> tv473)) * ((tv473 -> tv473) * (tv473 -> tv473))) * (((tv473 -> tv473) * (tv473 -> tv473)) * ((tv473 -> tv473) * (tv473 -> tv473)))) * ((((tv473 -> tv473) * (tv473 -> tv473)) * ((tv473 -> tv473) * (tv473 -> tv473))) * (((tv473 -> tv473) * (tv473 -> tv473)) * ((tv473 -> tv473) * (tv473 -> tv473)))))) * ((((((tv473 -> tv473) * (tv473 -> tv473)) * ((tv473 -> tv473) * (tv473 -> tv473))) * (((tv473 -> tv473) * (tv473 -> tv473)) * ((tv473 -> tv473) * (tv473 -> tv473)))) * ((((tv473 -> tv473) * (tv473 -> tv473)) * ((tv473 -> tv473) * (tv473 -> tv473))) * (((tv473 -> tv473) * (tv473 -> tv473)) * ((tv473 -> tv473) * (tv473 -> tv473))))) * (((((tv473 -> tv473) * (tv473 -> tv473)) * ((tv473 -> tv473) * (tv473 -> tv473))) * (((tv473 -> tv473) * (tv473 -> tv473)) * ((tv473 -> tv473) * (tv473 -> tv473)))) * ((((tv473 -> tv473) * (tv473 -> tv473)) * ((tv473 -> tv473) * (tv473 -> tv473))) * (((tv473 -> tv473) * (tv473 -> tv473)) * ((tv473 -> tv473) * (tv473 -> tv473)))))))) * ((((((((tv473 -> tv473) * (tv473 -> tv473)) * ((tv473 -> tv473) * (tv473 -> tv473))) * (((tv473 -> tv473) * (tv473 -> tv473)) * ((tv473 -> tv473) * (tv473 -> tv473)))) * ((((tv473 -> tv473) * (tv473 -> tv473)) * ((tv473 -> tv473) * (tv473 -> tv473))) * (((tv473 -> tv473) * (tv473 -> tv473)) * ((tv473 -> tv473) * (tv473 -> tv473))))) * (((((tv473 -> tv473) * (tv473 -> tv473)) * ((tv473 -> tv473) * (tv473 -> tv473))) * (((tv473 -> tv473) * (tv473 -> tv473)) * ((tv473 -> tv473) * (tv473 -> tv473)))) * ((((tv473 -> tv473) * (tv473 -> tv473)) * ((tv473 -> tv473) * (tv473 -> tv473))) * (((tv473 -> tv473) * (tv473 -> tv473)) * ((tv473 -> tv473) * (tv473 -> tv473)))))) * ((((((tv473 -> tv473) * (tv473 -> tv473)) * ((tv473 -> tv473) * (tv473 -> tv473))) * (((tv473 -> tv473) * (tv473 -> tv473)) * ((tv473 -> tv473) * (tv473 -> tv473)))) * ((((tv473 -> tv473) * (tv473 -> tv473)) * ((tv473 -> tv473) * (tv473 -> tv473))) * (((tv473 -> tv473) * (tv473 -> tv473)) * ((tv473 -> tv473) * (tv473 -> tv473))))) * (((((tv473 -> tv473) * (tv473 -> tv473)) * ((tv473 -> tv473) * (tv473 -> tv473))) * (((tv473 -> tv473) * (tv473 -> tv473)) * ((tv473 -> tv473) * (tv473 -> tv473)))) * ((((tv473 -> tv473) * (tv473 -> tv473)) * ((tv473 -> tv473) * (tv473 -> tv473))) * (((tv473 -> tv473) * (tv473 -> tv473)) * ((tv473 -> tv473) * (tv473 -> tv473))))))) * (((((((tv473 -> tv473) * (tv473 -> tv473)) * ((tv473 -> tv473) * (tv473 -> tv473))) * (((tv473 -> tv473) * (tv473 -> tv473)) * ((tv473 -> tv473) * (tv473 -> tv473)))) * ((((tv473 -> tv473) * (tv473 -> tv473)) * ((tv473 -> tv473) * (tv473 -> tv473))) * (((tv473 -> tv473) * (tv473 -> tv473)) * ((tv473 -> tv473) * (tv473 -> tv473))))) * (((((tv473 -> tv473) * (tv473 -> tv473)) * ((tv473 -> tv473) * (tv473 -> tv473))) * (((tv473 -> tv473) * (tv473 -> tv473)) * ((tv473 -> tv473) * (tv473 -> tv473)))) * ((((tv473 -> tv473) * (tv473 -> tv473)) * ((tv473 -> tv473) * (tv473 -> tv473))) * (((tv473 -> tv473) * (tv473 -> tv473)) * ((tv473 -> tv473) * (tv473 -> tv473)))))) * ((((((tv473 -> tv473) * (tv473 -> tv473)) * ((tv473 -> tv473) * (tv473 -> tv473))) * (((tv473 -> tv473) * (tv473 -> tv473)) * ((tv473 -> tv473) * (tv473 -> tv473)))) * ((((tv473 -> tv473) * (tv473 -> tv473)) * ((tv473 -> tv473) * (tv473 -> tv473))) * (((tv473 -> tv473) * (tv473 -> tv473)) * ((tv473 -> tv473) * (tv473 -> tv473))))) * (((((tv473 -> tv473) * (tv473 -> tv473)) * ((tv473 -> tv473) * (tv473 -> tv473))) * (((tv473 -> tv473) * (tv473 -> tv473)) * ((tv473 -> tv473) * (tv473 -> tv473)))) * ((((tv473 -> tv473) * (tv473 -> tv473)) * ((tv473 -> tv473) * (tv473 -> tv473))) * (((tv473 -> tv473) * (tv473 -> tv473)) * ((tv473 -> tv473) * (tv473 -> tv473)))))))))
pair@pair@pair@pair@pair@pair@pair@pair@fun@fun@pair@fun@fun@pair@pair@fun@fun@pair@fun@fun@pair@pair@pair@fun@fun@pair@fun@fun@pair@pair@fun@fun@pair@fun@fun@pair@pair@pair@pair@fun@fun@pair@fun@fun@pair@pair@fun@fun@pair@fun@fun@pair@pair@pair@fun@fun@pair@fun@fun@pair@pair@fun@fun@pair@fun@fun@pair@pair@pair@pair@pair@fun@fun@pair@fun@fun@pair@pair@fun@fun@pair@fun@fun@pair@pair@pair@fun@fun@pair@fun@fun@pair@pair@fun@fun@pair@fun@fun@pair@pair@pair@pair@fun@fun@pair@fun@fun@pair@pair@fun@fun@pair@fun@fun@pair@pair@pair@fun@fun@pair@fun@fun@pair@pair@fun@fun@pair@fun@fun@pair@pair@pair@pair@pair@pair@fun@fun@pair@fun@fun@pair@pair@fun@fun@pair@fun@fun@pair@pair@pair@fun@fun@pair@fun@fun@pair@pair@fun@fun@pair@fun@fun@pair@pair@pair@pair@fun@fun@pair@fun@fun@pair@pair@fun@fun@pair@fun@fun@pair@pair@pair@fun@fun@pair@fun@fun@pair@pair@fun@fun@pair@fun@fun@pair@pair@pair@pair@pair@fun@fun@pair@fun@fun@pair@pair@fun@fun@pair@fun@fun@pair@pair@pair@fun@fun@pair@fun@fun@pair@pair@fun@fun@pair@fun@fun@pair@pair@pair@pair@fun@fun@pair@fun@fun@pair@pair@fun@fun@pair@fun@fun@pair@pair@pair@fun@fun@pair@fun@fun@pair@pair@fun@fun@pair@fun@fun@pair@pair@pair@pair@pair@pair@pair@fun@fun@pair@fun@fun@pair@pair@fun@fun@pair@fun@fun@pair@pair@pair@fun@fun@pair@fun@fun@pair@pair@fun@fun@pair@fun@fun@pair@pair@pair@pair@fun@fun@pair@fun@fun@pair@pair@fun@fun@pair@fun@fun@pair@pair@pair@fun@fun@pair@fun@fun@pair@pair@fun@fun@pair@fun@fun@pair@pair@pair@pair@pair@fun@fun@pair@fun@fun@pair@pair@fun@fun@pair@fun@fun@pair@pair@pair@fun@fun@pair@fun@fun@pair@pair@fun@fun@pair@fun@fun@pair@pair@pair@pair@fun@fun@pair@fun@fun@pair@pair@fun@fun@pair@fun@fun@pair@pair@pair@fun@fun@pair@fun@fun@pair@pair@fun@fun@pair@fun@fun@pair@pair@pair@pair@pair@pair@fun@fun@pair@fun@fun@pair@pair@fun@fun@pair@fun@fun@pair@pair@pair@fun@fun@pair@fun@fun@pair@pair@fun@fun@pair@fun@fun@pair@pair@pair@pair@fun@fun@pair@fun@fun@pair@pair@fun@fun@pair@fun@fun@pair@pair@pair@fun@fun@pair@fun@fun@pair@pair@fun@fun@pair@fun@fun@pair@pair@pair@pair@pair@fun@fun@pair@fun@fun@pair@pair@fun@fun@pair@fun@fun@pair@pair@pair@fun@fun@pair@fun@fun@pair@pair@fun@fun@pair@fun@fun@pair@pair@pair@pair@fun@fun@pair@fun@fun@pair@pair@fun@fun@pair@fun@fun@pair@pair@pair@fun@fun@pair@fun@fun@pair@pair@fun@fun@pair@fun@fun
doc/examples/letpolytest5.spl
(bool -> int)
fun
doc/examples/squaresum.spl
unit
(1, 4, 9, 16, 25, 36, 49, 64, 81, 100)
unit
doc/examples/infiniteloop.spl
type error
doc/examples/hd.spl
tv553
runtime error
doc/examples/equal.spl
bool
true
doc/examples/nil.spl
int list
nil
doc/examples/null.spl
type error
doc/examples/factorial1.spl
int
3628800
doc/examples/strangeRecursion.spl
bool
true
doc/examples/lazyeval1.spl
int
2
doc/examples/lazyeval2.spl
int
1
doc/examples/lazyeval3.spl
int
1
doc/examples/infinitestream.spl
int
3628800
doc/examples/define.spl
int
0
doc/examples/mutualrecursion.spl
bool
{iseven=fun, isodd=fun}
{iszero=fun, isone=fun, istwo=fun}
true
false
false
true
false
doc/examples/tail.spl
int
50005000
```



